
\documentclass[11pt]{article}

\usepackage{xcolor}
\usepackage{chngcntr}
\usepackage{enumitem}
\usepackage[small]{titlesec}
\newlist{paragraphlist}{enumerate}{1}


\setlist[paragraphlist,1]{leftmargin=*,label={\bfseries \arabic*}}

\counterwithin{paragraphlisti}{subsubsection}




\title{{\Huge   Introduction and Related work}}

\author{Stav Alfi, Shachar Rosenman\\{\small Advisor: Prof. Dan Hefetz}}

\date{\today}

\begin{document}
  \maketitle

  \section*{Introduction}
  \begin{flushleft}

    TorrentX is a client side software for downloading and uploading torrents through the internet.
    There is a support for downloading and uploading the same torrent through a cluster which located in your private network. This architecture let us discover and use more seeders by examining more of them on different virtual/physical machines on a cluster.

  \end{flushleft}
  \begin{flushleft}

    TorrentX core algorithms will be developed by us from scratch.

  \end{flushleft}
  \begin{flushleft}

    In the recent years, BitTorrent has emerged as a scalable peer-to-peer file distribution mechanism.
    Because of the great popularity of the BitTorrent there is a lot of interest among the scientific community on whether it is possible to improve the performance of this protocol.
    So many measurement and analytical studies have published suggestions for different algorithms that achieves performance improvements.

  \end{flushleft}
  \begin{flushleft}

    Our goal is to select an algorithm, study it and then implement it to prove that the theoretical assumptions are indeed proven in experiments. Then we can publish it so users can enjoy even better performance
  \end{flushleft}

  \section*{How BitTorrent Works}
  \begin{flushleft}

    BitTorrent is a peer-to-peer protocol, which means that the computers in a BitTorrent “swarm” (a group of computers downloading and uploading the same torrent) transfer data between each other without the need for a central server, where all the information passes through a particular server.
    while the tracker server keeps track of where file copies reside on peer machines, which ones are available at time of the client request, and helps coordinate efficient transmission and reassembly of the copied file.

  \end{flushleft}
  \begin{flushleft}

    A server who responsible for saving the leechers (threads which attempting to download a torrent) and seeders (leechers who finished downloading the torrent) information is called a tracker. When a new leecher want to download, it sends a request to one of the avilable trackers in the torrent file and ask for all the peers (leechers and seeders). This request is called announcement.

  \end{flushleft}
  \begin{flushleft}

    It is importent to note that the tracker is refering to every peer by peer-public-ip.

  \end{flushleft}
  \begin{flushleft}

    \textbf{Public IP} address is the address that is assigned to a computing device to allow direct access over the Internet. A web server, email server and any server device directly accessible from the Internet are candidate for a public IP address. A public IP address is globally unique, and can only be assigned to a unique device.

  \end{flushleft}
  \begin{flushleft}

    Once a leecher is getting response from the tracker about a request to specific torrent's peer list, the leecher's BitTorrent client software downloads the pieces of the files. Each file in the torrent is divided into small information chunks called pieces. Each peace in the torrent have a constant size except the last peace. A peace size is defined in the torrent file. All in all, We can conclude that peers exchange peaces of multiple torrents concurrently in a distributed system.

  \end{flushleft}


  \section*{Peers massages}
  \begin{flushleft}

    To better understand how a given torrent algorithm works, we must understand what types of messages are transfered between peers in the p2p (peer-to-peer) protocol. Every message is described in the p2p protocol by what it's size must be, what it's content and by what order.

  \end{flushleft}
  \begin{flushleft}

    1. The keep-alive message is a message with zero bytes, specified with the length prefix set to zero. There is no message ID and no payload (extra data). Peers may close a connection if they receive no messages (keep-alive or any other message) for a certain period of time, so a keep-alive message must be sent to maintain the connection alive if no command have been sent for a given amount of time. This amount of time is generally two minutes.

  \end{flushleft}
  \begin{flushleft}

    2. Choke message means that if peer1 send it to peer2, then peer1 will ignore any future requests for peaces. We can conclude that peer1 is too busy. The choke message is fixed-length and has no payload.

  \end{flushleft}
  \begin{flushleft}

    3. Unchoke message means that if peer1 send it to peer2, then peer1 will no longer ignore any future requests for peaces. The unchoke message is fixed-length and has no payload.

  \end{flushleft}
  \begin{flushleft}

    4. Interested message means that if peer1 send it to peer2, peer1 want peaces which peer2 have to offer. The interested message is fixed-length and has no payload.

  \end{flushleft}
  \begin{flushleft}

    5. Not interested message means that if peer1 send it to peer2, peer1 does not want any peaces which peer2 have to offer.The not interested message is fixed-length and has no payload.

  \end{flushleft}
  \begin{flushleft}

    6. The have message is fixed length. The payload is the zero-based index of a piece that has just been successfully downloaded and verified via the hash.

  \end{flushleft}
  \begin{flushleft}

    Implementer's Note: That is the strict definition, in reality some games may be played. In particular because peers are extremely unlikely to download pieces that they already have, a peer may choose not to advertise having a piece to a peer that already has that piece. At a minimum "HAVE suppression" will result in a 0.5 reduction in the number of HAVE messages, this translates to around a 25-35% reduction in protocol overhead. At the same time, it may be worthwhile to send a HAVE message to a peer that has that piece already since it will be useful in determining which piece is rare.

  \end{flushleft}
  \begin{flushleft}

    7. The bitfield message may only be sent immediately after the handshaking sequence is completed, and before any other messages are sent. It is optional, and need not be sent if a client has no pieces.

  \end{flushleft}
  \begin{flushleft}

    The bitfield message is variable length, where X is the length of the bitfield. The payload is a bitfield representing the pieces that have been successfully downloaded. The high bit in the first byte corresponds to piece index 0. Bits that are cleared indicated a missing piece, and set bits indicate a valid and available piece. Spare bits at the end are set to zero.

  \end{flushleft}
  \begin{flushleft}

    A bitfield of the wrong length is considered an error. Clients should drop the connection if they receive bitfields that are not of the correct size, or if the bitfield has any of the spare bits set.

  \end{flushleft}
  \begin{flushleft}

    8. The request message is fixed length, and is used to request a block. The payload contains the following information: Index: integer specifying the zero-based piece index. Begin: integer specifying the zero-based byte offset within the piece. Length: integer specifying the requested length.

  \end{flushleft}
  \begin{flushleft}

    9. he piece message is variable length, where X is the length of the block. The payload contains the following information: Index: integer specifying the zero-based piece index. Begin: integer specifying the zero-based byte offset within the piece. Block: block of data, which is a subset of the piece specified by index.

  \end{flushleft}
  \begin{flushleft}

    10. The cancel message is fixed length, and is used to cancel block requests. The payload is identical to that of the "request" message. It is typically used during "End Game" (see the Algorithms section below).

  \end{flushleft}
  \begin{flushleft}

    Downloading peers achieve rapid download speeds by requesting multiple pieces from different computers simultaneously in the swarm.
    The torrent application download each peace and combine them togheter. Once the BitTorrent client has some data, it can then begin to upload that data to other BitTorrent clients in the swarm.

  \end{flushleft}
  \begin{flushleft}
  \end{flushleft}
  \begin{flushleft}

    Because multiple machines listen to the same port in the same network, we need to be able to get response from the WAN to the LAN. In short, \textbf{NAT} is a method of remapping public IP address and a port number to private ip address and a port number and vice versa. The majority of NATs map multiple private hosts to one publicly exposed IP address. In a typical configuration, a local network uses one of the designated private IP address. A router on that network has a private address in that address space. The router is also connected to the Internet with a public address. As traffic passes from the local network to the Internet, the source address in each packet is translated on the fly from a private address to the public address. The router tracks basic data about each active connection (particularly the destination address and port). When a reply returns to the router, it uses the connection tracking data it stored during the outbound phase to determine the private address on the internal network to which to forward the reply the system works fine until you want to give people on the outside Internet access to files. When they try to reach the computer through the public IP address they actually reach the router and the router doesn't know how to forward the connection to the appropriate computer, this way a leecher can not find the computer that has the file unless it's been told how to do so.

    A Bittorrent client application listen to a specific port in every machine. To be able to add this port to the NAT in it's router, one must use \textbf{universal plug in play (UPnP)} to avoid menually adding a port and a ip address to the NAT. The UPNP is a way to configure the NAT in any programming language. Telling the router which computer to forward a connection to is called \textbf{port forwarding}, each server based application has a port number it works through, its port number is very useful in giving the router the information it needs to forward a connection.

  \end{flushleft}

  \section*{Algorithms}
  \begin{flushleft}
    \textbf{Super Seeding} is a new seeding algorithm designed to help a torrent initiator with limited bandwidth "pump up" a large torrent, reducing the amount of data it needs to upload in order to spawn new seeds in the torrent.

  \end{flushleft}
  \begin{flushleft}

    When a seeding client enters "super-seed mode", it will not act as a standard seed, but masquerades as a normal client with no data. As clients connect, it will then inform them that it received a piece -- a piece that was never sent, or if all pieces were already sent, is very rare. This will induce the client to attempt to download only that piece.

  \end{flushleft}
  \begin{flushleft}

    When the client has finished downloading the piece, the seed will not inform it of any other pieces until it has seen the piece it had sent previously present on at least one other client. Until then, the client will not have access to any of the other pieces of the seed, and therefore will not waste the seed's bandwidth.

  \end{flushleft}
  \begin{flushleft}

    This method has resulted in much higher seeding efficiencies, by both inducing peers into taking only the rarest data, reducing the amount of redundant data sent, and limiting the amount of data sent to peers which do not contribute to the swarm. Prior to this, a seed might have to upload 150% to 200% of the total size of a torrent before other clients became seeds. However, a large torrent seeded with a single client running in super-seed mode was able to do so after only uploading 105% of the data. This is 150-200% more efficient than when using a standard seed.

  \end{flushleft}
  \begin{flushleft}

    Super-seed mode is 'NOT recommended for general use. While it does assist in the wider distribution of rare data, because it limits the selection of pieces a client can downlad, it also limits the ability of those clients to download data for pieces they have already partially retrieved. Therefore, super-seed mode is only recommended for initial seeding servers.

  \end{flushleft}
  \begin{flushleft}

    \textbf{End game algorithm} - When a download is almost complete, there's a tendency for the last few blocks to trickle in slowly. To speed this up, the client sends requests for all of its missing blocks to all of its peers. To keep this from becoming horribly inefficient, the client also sends a cancel to everyone else every time a block arrives.

  \end{flushleft}
  \begin{flushleft}

    There is no documented thresholds, recommended percentages, or block counts that could be used as a guide or Recommended Best Practice here.

  \end{flushleft}
  \begin{flushleft}

    When to enter end game mode is an area of discussion. Some clients enter end game when all pieces have been requested. Others wait until the number of blocks left is lower than the number of blocks in transit, and no more than 20. There seems to be agreement that it's a good idea to keep the number of pending blocks low (1 or 2 blocks) to minimize the overhead, and if you randomize the blocks requested, there's a lower chance of downloading duplicates.

  \end{flushleft}
  \begin{flushleft}

    \textbf{Choking and optimistic Unchoking algorithm} - Choking is done for several reasons. TCP congestion control behaves very poorly when sending over many connections at once. Also, choking lets each peer use a tit-for-tat-ish algorithm to ensure that they get a consistent download rate.

  \end{flushleft}
  \begin{flushleft}

    The choking algorithm described below is the currently deployed one. It is very important that all new algorithms work well both in a network consisting entirely of themselves and in a network consisting mostly of this one.

  \end{flushleft}
  \begin{flushleft}

    There are several criteria a good choking algorithm should meet. It should cap the number of simultaneous uploads for good TCP performance. It should avoid choking and unchoking quickly, known as 'fibrillation'. It should reciprocate to peers who let it download. Finally, it should try out unused connections once in a while to find out if they might be better than the currently used ones, known as optimistic unchoking.

  \end{flushleft}
  \begin{flushleft}

    The currently deployed choking algorithm avoids fibrillation by only changing choked peers once every ten seconds.

  \end{flushleft}
  \begin{flushleft}

    Reciprocation and number of uploads capping is managed by unchoking the four peers which have the best upload rate and are interested. This maximizes the client's download rate. These four peers are referred to as downloaders, because they are interested in downloading from the client.

  \end{flushleft}
  \begin{flushleft}

    Peers which have a better upload rate (as compared to the downloaders) but aren't interested get unchoked. If they become interested, the downloader with the worst upload rate gets choked. If a client has a complete file, it uses its upload rate rather than its download rate to decide which peers to unchoke.

  \end{flushleft}
  \begin{flushleft}

    For optimistic unchoking, at any one time there is a single peer which is unchoked regardless of its upload rate (if interested, it counts as one of the four allowed downloaders). Which peer is optimistically unchoked rotates every 30 seconds. Newly connected peers are three times as likely to start as the current optimistic unchoke as anywhere else in the rotation. This gives them a decent chance of getting a complete piece to upload.

  \end{flushleft}
  \begin{flushleft}

    \textbf{Anti-snubbing} - Occasionally a BitTorrent peer will be choked by all peers which it was formerly downloading from. In such cases it will usually continue to get poor download rates until the optimistic unchoke finds better peers. To mitigate this problem, when over a minute goes by without getting any piece data while downloading from a peer, BitTorrent assumes it is "snubbed" by that peer and doesn't upload to it except as an optimistic unchoke. This frequently results in more than one concurrent optimistic unchoke, (an exception to the exactly one optimistic unchoke rule mentioned above), which causes download rates to recover much more quickly when they falter.

  \end{flushleft}

  \section*{Our application}
  \begin{flushleft}

    In short, a leecher can choose to download the peaces in a specific order (from the first peace to the last) so one can watch a movie while downloading it.

  \end{flushleft}
\end{document}
